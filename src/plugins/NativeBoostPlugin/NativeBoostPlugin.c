/* Automatically generated by
	VMPluginCodeGenerator * VMMaker.oscog-EstebanLorenzano.746 uuid: 7091499b-788c-4871-a077-60abea56aa58
   from
	CogNativeBoostPlugin * NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66
 */
static char __buildInfo[] = "CogNativeBoostPlugin * NativeBoost-CogPlugin-GuillermoPolito.19 uuid: acc98e51-2fba-4841-a965-2975997bba66 " __DATE__ ;



#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <dlfcn.h>
#include <setjmp.h>

/* Default EXPORT macro that does nothing (see comment in sq.h): */
#define EXPORT(returnType) returnType

/* Do not include the entire sq.h file but just those parts needed. */
/*  The virtual machine proxy definition */
#include "sqVirtualMachine.h"
/* Configuration options */
#include "sqConfig.h"
/* Platform specific definitions */
#include "sqPlatformSpecific.h"

#define true 1
#define false 0
#define null 0  /* using 'null' because nil is predefined in Think C */
#ifdef SQUEAK_BUILTIN_PLUGIN
#undef EXPORT
// was #undef EXPORT(returnType) but screws NorCroft cc
#define EXPORT(returnType) static returnType
#endif

#include "sqMemoryAccess.h"


/*** Constants ***/
#define ErrInvalidPlatformId 503
#define ErrNoNativeCodeInMethod 502
#define ErrNotEnabled 501
#define NativeCodeTrailerId 40
#define PlatformId 2


/*** Function Prototypes ***/
static VirtualMachine * getInterpreter(void);
EXPORT(const char*) getModuleName(void);
static sqInt halt(void);
EXPORT(sqInt) initialiseModule(void);
static sqInt msg(char *s);
EXPORT(sqInt) primitiveDlopenFn(void);
EXPORT(sqInt) primitiveDlsymFn(void);
EXPORT(sqInt) primitiveEnable(void);
EXPORT(sqInt) primitiveGetInterpreterProxy(void);
EXPORT(sqInt) primitiveIsEnabled(void);
EXPORT(sqInt) primitiveLastNativeCodeError(void);
EXPORT(sqInt) primitiveNativeCall(void);
EXPORT(sqInt) primitivePlatformId(void);
EXPORT(sqInt) primJumpBufSize(void);
EXPORT(sqInt) setInterpreter(struct VirtualMachine*anInterpreter);


/*** Variables ***/
static sqInt enabled;

#if !defined(SQUEAK_BUILTIN_PLUGIN)
static sqInt (*falseObject)(void);
static void * (*firstFixedField)(sqInt oop);
static sqInt (*integerObjectOf)(sqInt value);
static sqInt (*methodArgumentCount)(void);
static sqInt (*popthenPush)(sqInt nItems, sqInt oop);
static sqInt (*positive32BitIntegerFor)(sqInt integerValue);
static sqInt (*primitiveFailureCode)(void);
static sqInt (*primitiveMethod)(void);
static sqInt (*signed32BitIntegerFor)(sqInt integerValue);
static sqInt (*slotSizeOf)(sqInt oop);
static sqInt (*trueObject)(void);
#else /* !defined(SQUEAK_BUILTIN_PLUGIN) */
extern sqInt falseObject(void);
extern void * firstFixedField(sqInt oop);
extern sqInt integerObjectOf(sqInt value);
extern sqInt methodArgumentCount(void);
extern sqInt popthenPush(sqInt nItems, sqInt oop);
extern sqInt positive32BitIntegerFor(sqInt integerValue);
extern sqInt primitiveFailureCode(void);
extern sqInt primitiveMethod(void);
extern sqInt signed32BitIntegerFor(sqInt integerValue);
extern sqInt slotSizeOf(sqInt oop);
extern sqInt trueObject(void);
extern
#endif
struct VirtualMachine* interpreterProxy;
static sqInt lastError;
static const char *moduleName =
#ifdef SQUEAK_BUILTIN_PLUGIN
	"NativeBoostPlugin * NativeBoost-CogPlugin-GuillermoPolito.19 (i)"
#else
	"NativeBoostPlugin * NativeBoost-CogPlugin-GuillermoPolito.19 (e)"
#endif
;



/*	Note: This is coded so that plugins can be run from Squeak. */

static VirtualMachine *
getInterpreter(void)
{
	// InterpreterPlugin>>#getInterpreter
	return interpreterProxy;
}


/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

EXPORT(const char*)
getModuleName(void)
{
	// InterpreterPlugin>>#getModuleName
	return moduleName;
}

static sqInt
halt(void)
{
	// InterpreterPlugin>>#halt
	;
	return 0;
}

EXPORT(sqInt)
initialiseModule(void)
{
	// CogNativeBoostPlugin>>#initialiseModule
	enabled = 0;
	return 1;
}

static sqInt
msg(char *s)
{
	// InterpreterPlugin>>#msg:
	fprintf(stderr, "\n%s: %s", moduleName, s);
	return 0;
}

EXPORT(sqInt)
primitiveDlopenFn(void)
{
	// CogNativeBoostPlugin>>#primitiveDlopenFn
    void*addr;

	addr = 0;
	
		#ifdef RTLD_DEFAULT
			addr = (void*) &dlopen
		#endif
	;
	popthenPush((methodArgumentCount()) + 1, positive32BitIntegerFor(addr));
}


/*	return a dlsym() function address */

EXPORT(sqInt)
primitiveDlsymFn(void)
{
	// CogNativeBoostPlugin>>#primitiveDlsymFn
    void*addr;

	addr = 0;
	
		#ifdef RTLD_DEFAULT
			addr = (void*) &dlsym
		#endif
	;
	popthenPush((methodArgumentCount()) + 1, positive32BitIntegerFor(addr));
}

EXPORT(sqInt)
primitiveEnable(void)
{
	// CogNativeBoostPlugin>>#primitiveEnable
	enabled = 1;
}


/*	return a pointer to interpreterProxy struct as usqInt */

EXPORT(sqInt)
primitiveGetInterpreterProxy(void)
{
	// CogNativeBoostPlugin>>#primitiveGetInterpreterProxy
	popthenPush(1, positive32BitIntegerFor(((usqInt) interpreterProxy)));
}

EXPORT(sqInt)
primitiveIsEnabled(void)
{
	// CogNativeBoostPlugin>>#primitiveIsEnabled
    sqInt result;

	if (enabled) {
		result = trueObject();
	}
	else {
result = falseObject();
	}
	popthenPush((methodArgumentCount()) + 1, result);
}


/*	return a primitive failure code, set during last use of
	#primitiveNativeCall 
 */

EXPORT(sqInt)
primitiveLastNativeCodeError(void)
{
	// CogNativeBoostPlugin>>#primitiveLastNativeCodeError
	popthenPush(1, signed32BitIntegerFor(lastError));
}

EXPORT(sqInt)
primitiveNativeCall(void)
{
	// CogNativeBoostPlugin>>#primitiveNativeCall
    sqInt argCount;
    sqInt codeOffset;
    sqInt (*fnPtr)(void);
    sqInt len;
    sqInt nativeMethod;
    sqInt platformId;
    sqInt result;
    sqInt trailer;

	if (!enabled) {
		return primitiveFailFor((lastError = ErrNotEnabled));
	}
	nativeMethod = primitiveMethod();
	len = slotSizeOf(nativeMethod);
	trailer = byteAt(((nativeMethod + BaseHeaderSize) + len) - 1);
	if (!((trailer & 0xFC) == NativeCodeTrailerId)) {

		/* Native code trailer */

return primitiveFailFor((lastError = ErrNoNativeCodeInMethod));
	}
	platformId = (byteAt(((nativeMethod + BaseHeaderSize) + len) - 2)) + ((byteAt(((nativeMethod + BaseHeaderSize) + len) - 3)) << 8);
	if (!(platformId == PlatformId)) {
		return primitiveFailFor((lastError = ErrInvalidPlatformId));
	}
	codeOffset = (byteAt(((nativeMethod + BaseHeaderSize) + len) - 4)) + ((byteAt(((nativeMethod + BaseHeaderSize) + len) - 5)) << 8);

	/* entry point address is method oop + header + len - codeOffset */

argCount = methodArgumentCount();
	fnPtr = ((sqInt (*)(void)) (((((char*) (firstFixedField(nativeMethod)))) + len) - codeOffset));
	result = fnPtr();
	if (failed()) {
		lastError = primitiveFailureCode();
	}
	else {
popthenPush(argCount + 1, result);
	}
}


/*	return a platform id code */

EXPORT(sqInt)
primitivePlatformId(void)
{
	// CogNativeBoostPlugin>>#primitivePlatformId
	popthenPush((methodArgumentCount()) + 1, integerObjectOf(PlatformId));
}

EXPORT(sqInt)
primJumpBufSize(void)
{
	// CogNativeBoostPlugin>>#primJumpBufSize
	popthenPush((methodArgumentCount()) + 1, positive32BitIntegerFor(sizeof(jmp_buf)));
}


/*	Note: This is coded so that it can be run in Squeak. */

EXPORT(sqInt)
setInterpreter(struct VirtualMachine*anInterpreter)
{
	// InterpreterPlugin>>#setInterpreter:
    sqInt ok;

	interpreterProxy = anInterpreter;
	ok = ((interpreterProxy->majorVersion()) == (VM_PROXY_MAJOR))
	 && ((interpreterProxy->minorVersion()) >= (VM_PROXY_MINOR));
	if (ok) {

#if !defined(SQUEAK_BUILTIN_PLUGIN)
		falseObject = interpreterProxy->falseObject;
		firstFixedField = interpreterProxy->firstFixedField;
		integerObjectOf = interpreterProxy->integerObjectOf;
		methodArgumentCount = interpreterProxy->methodArgumentCount;
		popthenPush = interpreterProxy->popthenPush;
		positive32BitIntegerFor = interpreterProxy->positive32BitIntegerFor;
		primitiveFailureCode = interpreterProxy->primitiveFailureCode;
		primitiveMethod = interpreterProxy->primitiveMethod;
		signed32BitIntegerFor = interpreterProxy->signed32BitIntegerFor;
		slotSizeOf = interpreterProxy->slotSizeOf;
		trueObject = interpreterProxy->trueObject;
#endif /* !defined(SQUEAK_BUILTIN_PLUGIN) */
	}
	return ok;
}


#ifdef SQUEAK_BUILTIN_PLUGIN

void* NativeBoostPlugin_exports[][3] = {
	{"NativeBoostPlugin", "getModuleName", (void*)getModuleName},
	{"NativeBoostPlugin", "initialiseModule", (void*)initialiseModule},
	{"NativeBoostPlugin", "primitiveDlopenFn\000\377", (void*)primitiveDlopenFn},
	{"NativeBoostPlugin", "primitiveDlsymFn\000\377", (void*)primitiveDlsymFn},
	{"NativeBoostPlugin", "primitiveEnable\000\377", (void*)primitiveEnable},
	{"NativeBoostPlugin", "primitiveGetInterpreterProxy\000\377", (void*)primitiveGetInterpreterProxy},
	{"NativeBoostPlugin", "primitiveIsEnabled\000\377", (void*)primitiveIsEnabled},
	{"NativeBoostPlugin", "primitiveLastNativeCodeError\000\377", (void*)primitiveLastNativeCodeError},
	{"NativeBoostPlugin", "primitiveNativeCall\000\377", (void*)primitiveNativeCall},
	{"NativeBoostPlugin", "primitivePlatformId\000\377", (void*)primitivePlatformId},
	{"NativeBoostPlugin", "primJumpBufSize\000\377", (void*)primJumpBufSize},
	{"NativeBoostPlugin", "setInterpreter", (void*)setInterpreter},
	{NULL, NULL, NULL}
};

#else /* ifdef SQ_BUILTIN_PLUGIN */


#endif /* ifdef SQ_BUILTIN_PLUGIN */
