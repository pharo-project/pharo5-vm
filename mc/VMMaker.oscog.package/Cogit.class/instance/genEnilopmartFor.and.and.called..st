initialization
genEnilopmartFor: regArg1 and: regArg2 and: regArg3 called: trampolineName
	"An enilopmart (the reverse of a trampoline) is a piece of code that makes
	 the system-call-like transition from the C runtime into generated machine
	 code.  The desired arguments and entry-point are pushed on a stackPage's
	 stack.  The enilopmart pops off the values to be loaded into registers and
	 then executes a return instruction to pop off the entry-point and jump to it.

						BEFORE				AFTER			(stacks grow down)
						whatever			stackPointer ->	whatever
						target address =>	reg1 = reg1val, etc
						reg1val				pc = target address
						reg2val
		stackPointer ->	reg3val

	C.F. genCallEnilopmartFor:and:and:called:"
	<returnTypeC: 'void (*genEnilopmartForandandcalled(sqInt regArg1, sqInt regArg2, sqInt regArg3, char *trampolineName))(void)'>
	| size endAddress enilopmart |
	opcodeIndex := 0.
	backEnd genLoadStackPointers.
	self PopR: regArg3.
	self PopR: regArg2.
	self PopR: regArg1.
	backEnd hasLinkRegister
		ifTrue: [backEnd hasPCRegister
					ifTrue: [self PopR: PCReg]
					ifFalse: [self PopR: LinkReg; RetN: 0]]
		ifFalse: [self RetN: 0].
	self computeMaximumSizes.
	size := self generateInstructionsAt: methodZoneBase.
	endAddress := self outputInstructionsAt: methodZoneBase.
	self assert: methodZoneBase + size = endAddress.
	enilopmart := methodZoneBase.
	methodZoneBase := self alignUptoRoutineBoundary: endAddress.
	backEnd nopsFrom: endAddress to: methodZoneBase - 1.
	self recordGeneratedRunTime: trampolineName address: enilopmart.
	^self cCoerceSimple: enilopmart to: #'void (*)(void)'