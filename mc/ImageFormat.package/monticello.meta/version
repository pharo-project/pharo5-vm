(name 'ImageFormat-dtl.20' message 'Spur:Resolve the conflict between 32-bit and 64-bit tag assignments.  In 32-bits wehave 1=even SmallIntegers, 2=Characters, 3=odd SmallIntegers, and in 64-bits wehad 1=SmallIntegers, 2=Characters, 3=SmallFloats.  Hence we would wantSmallFloat64''s identityHash to be 3, which conflicts with 32 bits'' oddSmallIntegers.  Change is for 64-bits to use 1=SmallIntegers, 2=Characters,4=SmallFloats.  This also means single-bit tests in the Cogit, which producesbetter code, and no scratch registers to hold masked tags.Hence roll the 64-bit Spur image format version number from 68019 to 68021.' id '62b8d3f2-7457-4176-898f-66631d97ccc1' date '12 March 2016' time '12:02:40.549 am' author 'dtl' ancestors ((name 'ImageFormat-dtl.19' message 'fix comment' id '5cc40fa2-9edb-414f-9421-4f3f59193818' date '9 November 2014' time '5:21:39.097 pm' author 'dtl' ancestors ((name 'ImageFormat-dtl.18' message 'Read Spur 32 and 64 bit image headers.' id '03405b51-1796-4492-8857-24051f1ce38a' date '9 November 2014' time '5:14:48.61 pm' author 'dtl' ancestors ((name 'ImageFormat-dtl.17' message 'Assign image format numbers 6521 and 68019 to the Spur object format. Assume that Spur extends existing Cog requirements, and that bit 5 of the format number identifies an image that requires Spur support from the VM. Update unit tests to document the new format numbers.The assigned image format numbers are:a 64-bit image with no closure support and no native platform float word order requirement (68000)a 64-bit image with closure support and no native platform float word order requirement (68002)a 64-bit image with closure support and float words stored in native platform order (68003)a 64-bit image with closure support and float words stored in native platform order using Spur object format (68019)a 32-bit image with no closure support and no native platform float word order requirement (6502)a 32-bit image with closure support and no native platform float word order requirement (6504)a 32-bit image with closure support and float words stored in native platform order (6505)a 32-bit image with closure support and float words stored in native platform order using Spur object format (6521)' id 'c0eac484-fb27-48d6-8c7a-69c1b95f52bc' date '9 October 2013' time '10:36:05.224 pm' author 'dtl' ancestors ((name 'ImageFormat-dtl.16' message 'Add a newline to the output of the ckformat program to make it useful as a command line utility, with no impact on shell scripts that use it. Also fix horribly named methods.' id '1cad9e33-6534-4140-8730-c316e5291e90' date '8 December 2012' time '8:38:44.785 pm' author 'dtl' ancestors ((name 'ImageFormat-dtl.15' message 'Clean up accessors in ImageFileHeader' id '51e0b41e-bded-4776-b67c-b0e8362dfa97' date '1 November 2012' time '8:48:57.892 pm' author 'dtl' ancestors ((name 'ImageFormat-dtl.14' message 'Add updates to ImageFormat to report #availableBits and bitAssignments.Add ImageFileHeader and CogImageFileHeader with tests in ImageFileHeaderTest.The purpose of ImageFileHeader is to document the current formats of Cog and interpreter image file headers, and to provide a convenient way to inspect the data values an image file header.To explore the file header of an image file:  | fs |  fs := (FileStream readOnlyFileNamed: Smalltalk imageName) binary.  ([CogImageFileHeader readFrom: fs] ensure: [fs close]) explore' id '76bad473-3b56-48fa-8fa7-80d8c7afc523' date '1 November 2012' time '7:52:14.48 am' author 'dtl' ancestors ((name 'ImageFormat-dtl.13' message 'Remove obsolete reference to squeaksource in source code comment.' id 'c91774f6-c505-414e-9d19-a87a98a93992' date '21 September 2012' time '7:59:36.391 pm' author 'dtl' ancestors ((name 'ImageFormat-dtl.12' message 'Close file after reading image format in #fromFile:' id '08000000-1508-3c14-1508-3c1414000000' date '11 July 2011' time '9:29:46.408 pm' author 'dtl' ancestors ((name 'ImageFormat-dtl.11' message 'Better description and method names for the Float platform word order requirement (bit 1 set).' id 'c1d30608-30f8-51b7-208a-2ff7a46c1508' date '18 April 2011' time '7:56:11.908 pm' author 'dtl' ancestors ((name 'ImageFormat-topa.10' message 'Cope for 512byte offset that may possibly preceedethe acutual image content.' id '96fb9f3c-0c65-4789-a6c5-985cf5e5c3d8' date '20 January 2011' time '10:08:28.348 pm' author 'topa' ancestors ((name 'ImageFormat-dtl.9' message 'Fix ImageFormat class>>initialize' id '99863582-1c72-469b-a147-8cec3f350ef5' date '8 January 2011' time '9:57:11.939 am' author 'dtl' ancestors ((name 'ImageFormat-dtl.8' message 'Generate better C source for ckformat utility, and make the generator work with VMMaker.' id 'b1893ec4-9646-46a4-9aa2-faa210f08c18' date '2 January 2011' time '5:57:56.97 pm' author 'dtl' ancestors ((name 'ImageFormat-dtl.7' message 'Generate ckformat.c, a utility program for reading the image file format number from an image file. The ckformat program is intended for testing image file format from a unix shell script such that the shell script can select a VM based on image requirements. A non-zero return status code from ckformat indicates failure, otherwise the format number is written to standard output with no line terminator. The utility handles big-endian and little-endian versions of all known 32 and 64 bit image formats.The ckformat C code is generated from ImageFormat to ensure that it is updated as new format numbers are assigned and documented in class ImageFormat.' id 'a8499caf-2b80-4c5c-82e7-e2b10455f42a' date '31 December 2010' time '6:40:20.178 pm' author 'dtl' ancestors ((name 'ImageFormat-dtl.6' message 'ImageFormat fromFile: Smalltalk imageName "read ImageFormat from disk image file"ImageFormat allVersionNumberByteArrays "known formats as byte arrays"' id '5185382f-dce7-4520-827e-9de0e791789c' date '1 December 2010' time '10:51:41.041 pm' author 'dtl' ancestors ((name 'ImageFormat-dtl.5' message 'Read the image format from a snapshot image file header, checking byte ordering and 32/64 bit word size.  (ImageFormat fromFile: Smalltalk imageName)      description ==> ''A 32-bit image with closure support and no Cog byte reversal (6504)''' id 'a5928c3e-82de-41b6-8903-46cc3e48cb13' date '7 November 2010' time '10:21:40.927 pm' author 'dtl' ancestors ((name 'ImageFormat-dtl.4' message 'ImageFormat represents the requirements of the image in terms of capabilities that must be supported by the virtual machine. The image format version is saved as an integer value in the header of an image file. When an image is loaded, the virtual machine checks the image format version to determine whether it is capable of supporting the requirements of that image.The image format version value is treated as a bit map of size 32, derived from the 32-bit integer value saved in the image header. Bits in the bit map represent image format requirements. For example, if the image sets bit 15 to indicate that it requires some capability from the VM, then the VM can check bit 15 and decide whether it is able to satisfy that requirement.The base image format numbers (6502, 6504, 68000, and 68002) utiliize 10 of the 32 available bits. The high order bit is reserved as an extension bit for future use. The remaining 21 bits are used to represent additional image format requirements. For example, the low order bit is used to indication that the image uses (and requires support for) the platform byte ordering implemented in the StackInterpreter (Cog) VM.' id 'e7a75dec-4cba-4fa3-9c22-55956d3f8ae1' date '6 September 2010' time '3:48:31.515 pm' author 'dtl' ancestors ((name 'ImageFormat-dtl.3' message 'ImageFormat represents the requirements of the image in terms of capabilities that must be supported by the virtual machine. The image format version is saved as an integer value in the header of an image file. When an image is loaded, the virtual machine checks the image format version to determine whether it is capable of supporting the requirements of that image.The image format version value is treated as a bit map of size 32, derived from the 32-bit integer value saved in the image header. Bits in the bit map represent image format requirements. For example, if the image sets bit 15 to indicate "needs object header inversion", then VM can check bit 15 and decide whether it can support this (whimsical) requirement.The base image format numbers (6502, 6504, 68000, and 68002) utiliize 10 of the 32 available bits. The high order bit is reserved as an extension bit for future use. The remaining 21 bits are used to represent additional image format requirements. For example, the low order bit is used to indication that the image uses (and requires support for) the platform byte ordering implemented in the StackInterpreter (Cog) VM.' id '723a84de-2930-4cc0-b30f-7692e9f1874f' date '6 September 2010' time '11:58:54.096 am' author 'dtl' ancestors ((name 'ImageFormat-dtl.2' message 'ImageFormat represents the requirements of the image in terms of capabilities that should be supported by the virtual machine. The image format version is saved as an integer value in the header of an image file. When an image is loaded, the virtual machine checks the image format version to determine whether it is capable of supporting the requirements of that image.' id '2168cede-29a8-4b44-9926-eab56c371ae0' date '6 September 2010' time '10:41:00.752 am' author 'dtl' ancestors ((name 'ImageFormat-dtl.1' message 'ImageFormatVersion represents the requirements of the image in terms of capabilities that should be supported by the virtual machine. The image format version is saved as an integer value in the header of an image file. When an image is loaded, the virtual machine checks the image format version to determine whether it is capable of supporting the requirements of that image.' id 'aedcccb5-a236-4175-a318-65f3ae6c9bbf' date '5 September 2010' time '12:33:20.545 pm' author 'dtl' ancestors () stepChildren ())) stepChildren ())) stepChildren ())) stepChildren ())) stepChildren ())) stepChildren ())) stepChildren ())) stepChildren ())) stepChildren ())) stepChildren ())) stepChildren ())) stepChildren ())) stepChildren ())) stepChildren ())) stepChildren ())) stepChildren ())) stepChildren ())) stepChildren ())) stepChildren ())) stepChildren ())